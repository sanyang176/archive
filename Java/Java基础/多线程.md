同步异步，C#中有，async修饰的方法，表示异步方法，方法可以先返回一个值，完成调用，之后继续往下执行与返回值无关的内容，等方法返回值后，恢复上下文继续执行
java CompletableFuture
```
CompletableFuture.supplyAsync(() -> fetchUser(userId))
    .thenApply(user -> validateUser(user))
    .thenCompose(valid -> valid ? loadProfile(userId) : failedFuture("Invalid user"))
    .thenAccept(profile -> updateUI(profile))
    .exceptionally(ex -> {
        showError(ex.getMessage());
        return null;
    });
```
乐观锁和悲观锁
两种悲观锁的实现：
```
public class TestSychronizeClass {
    private int count = 10;
    private int countNotSychrognized = 8;
    public void BuyTickets(){
        synchronized(this){
            System.out.println("票价为：" + count);
            count = count - 1;
        }

        System.out.println("非同步票价为：" + countNotSychrognized);
        countNotSychrognized = countNotSychrognized - 1;
    }
}
```
```
public class TestLockClass {
    private int count = 10;
    private int countNotSychrognized = 8;
    private final ReentrantLock lock = new ReentrantLock();

    public void BuyTickets(){
        lock.lock();
        try{
            System.out.println("Lock票价为：" + count);
            count = count - 1;
        }
        finally{
            lock.unlock();
        }

        System.out.println("Lock非同步票价为：" + countNotSychrognized);
        countNotSychrognized = countNotSychrognized - 1;
    }
}
```
这两种模式的区别：sychhronized可以修饰不同方法、静态方法和代码块，lock只能修饰代码块。在锁的添加和释放上，sychhronized可以实现锁的自动添加和释放，lock需要调用lock和unlock的方法进行锁的添加和释放
