Mysql innodb引擎中的B+树索引，具体可以表述如下：
索引：有无索引的区别：无索引的情况下，查询需要遍历表格的每一行，有索引的情况下，会使用索引快速定位
在聚集索引查找过程中，B+树在非叶子节点只存储聚集索引号，在叶子节点按照链式存储，假如我要select * from table where id >= 18 and id <=40
那么查找过程是先在第一页找到页三，根据页三找到>=18的id值，并按照链式查找到22。之后按照p指针链式查找，查找24…39。到下一个41时，不满足条件，查找结束。由于该B+树在叶子节点上不仅存储了id值，还存储了对应的数据，因此不需要多余操作

对于非聚集索引查找，则在聚集索引查找的基础上多了一步，即先构建非聚集索引B+树，里面存储非聚集索引-聚集索引，通过非聚集索引找到所有聚集索引，之后进行回表操作，按照聚集索引树进行查找。

SQL语句 create index {indexname} on {tablename}({columnname})
可以使用单个索引，多个索引，unique创建唯一索引
回表查询：如果索引的列在select所在的列中，那么不需要在表中找到列的信息，即不需要回表
聚集索引：聚集索引存储行记录，如果有主键，主键就是聚集索引，否则会创建一个隐藏的rowid
低级索引 -> 高级索引 -> 拿到表中数据
索引覆盖： 可以把不在索引中的查询属性加到索引中
 	比如： 建立一个表 
create table user1{
	id int primary key,
	name varchar(20),
	sex varchar(5),
	index(name)	
}engine=innodb
假如select * from user1 where id = 1 覆盖了所有索引，不需要回表
假如select name,id from user1 where name = "aa" 覆盖了所有索引，不需要回表
假如select name,idsex from user1 where name = "aa" 没有覆盖sex，需要回表
假如create table时index设为name和index，那么索引中包含了所有类，就实现了索引覆盖
因此，避免select * ，这样有索引时需要回表，增加查询时间

sql基本语法,不区分大小写
向表中增删改查数据：
insert into tablename values("value1","value2")
insert into tablename(key1,key2) values("value1","value2")
insert into tablename(key1) select key1 from table
update tablename set key1 = 'value1',key2 = 'value2' where ****
delete from tablename where ***
truncate table tablename
（按照列放置）
select * from tablename where ***
select distinct * from tablename  ***
select 8 from tablename limit 100,,10
like-where
where name like "%Greet"
where name like "__Greet"
select * from tablename1 A left join/right join.inner join tablename2 B on A.key = b.key where A.key is null And ***
select * from users where （列数必须相同，按照行放置）
union
select * from users2 where
select * from tablename orderby key1 desc. key2 aesc
select count(key) as a from customers group by **
having+groupby 分组后筛选

create database databasename
drop database databasename
use databasename

create table tablename(
keyname,keytype, keyconfig,comment
....
)commect = "**"
create table tablename as select * fro0m tablename2
drop table tablename 

alter table tablename add key,keytype
alter table tablename drop column keyname
alter table tablename modify column key keytype
alter table tablename add primary key (keyname)
alter table tablename drop primary key

create index indexname on tablename(id)
create unique index indexname on tablename(id)
alter table tablename drop index indexname

CREATE TABLE Users (
  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',
  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',
  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',
  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',
  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',
  PRIMARY KEY (Id)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';

-- 开始事务
START TRANSACTION;
 
-- 插入操作 A
INSERT INTO `user`
VALUES (1, 'root1', 'root1', 'xxxx@163.com');
 
-- 创建保留点 updateA
SAVEPOINT updateA;
 
-- 插入操作 B
INSERT INTO `user`
VALUES (2, 'root2', 'root2', 'xxxx@163.com');
 
-- 回滚到保留点 updateA
ROLLBACK TO updateA;
 
-- 提交事务，只有操作 A 生效
COMMIT;

USE mysql;
SELECT user FROM user;

CREATE USER myuser IDENTIFIED BY 'mypassword';

UPDATE user SET user='newuser' WHERE user='myuser';
FLUSH PRIVILEGES;

DROP USER myuser;

GRANT SELECT, INSERT ON *.* TO myuser;

REVOKE SELECT, INSERT ON *.* FROM myuser;

SET PASSWORD FOR myuser = 'mypass';

DROP PROCEDURE IF EXISTS `proc_adder`;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `proc_adder`(IN a int, IN b int, OUT sum int)
BEGIN
    DECLARE c int;
    if a is null then set a = 0;
    end if;
 
    if b is null then set b = 0;
    end if;
 
    set sum  = a + b;
END
;;
DELIMITER ;

set @b=5;
call proc_adder(2,@b,@s);
select @s as sum;

DELIMITER $
CREATE  PROCEDURE getTotal()
BEGIN
    DECLARE total INT;
    -- 创建接收游标数据的变量
    DECLARE sid INT;
    DECLARE sname VARCHAR(10);
    -- 创建总数变量
    DECLARE sage INT;
    -- 创建结束标志变量
    DECLARE done INT DEFAULT false;
    -- 创建游标
    DECLARE cur CURSOR FOR SELECT id,name,age from cursor_table where age>30;
    -- 指定游标循环结束时的返回值
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;
    SET total = 0;
    OPEN cur;
    FETCH cur INTO sid, sname, sage;
    WHILE(NOT done)
    DO
        SET total = total + 1;
        FETCH cur INTO sid, sname, sage;
    END WHILE;
 
    CLOSE cur;
    SELECT total;
END $
DELIMITER ;
 
-- 调用存储过程
call getTotal();

CREATE TRIGGER trigger_name
trigger_time
trigger_event
ON table_name
FOR EACH ROW
BEGIN
  trigger_statements
END;
DELIMITER $
CREATE TRIGGER `trigger_insert_user`
AFTER INSERT ON `user`
FOR EACH ROW
BEGIN
    INSERT INTO `user_history`(user_id, operate_type, operate_time)
    VALUES (NEW.id, 'add a user',  now());
END $
DELIMITER ;
SHOW TRIGGERS;
DROP TRIGGER IF EXISTS trigger_insert_user;
